#!/usr/bin/env perl

use strict;
use warnings;
use File::Spec;

my $BUCKET_NUM=10000;
my $PROGRAM="formatter";
my $usage=
"Usage: $PROGRAM 
	index 		extract chr, start, end, ref, alt rsID from ANNOVAR dbSNP, sort and index by rsID
	findbin 	return start, end line number for an rsID
	csv2tab		replace all commas by tab
	rs2avinput 	remove header and convert rsID to AVINPUT format\n";
die $usage if @ARGV<1;
my $op=shift @ARGV;

if ($op =~ /csv2tab/i)
{
    &csv2tab(@ARGV);
} elsif ($op =~ /rs2avinput/i)
{
    &rs2avinput(@ARGV);
}elsif ($op =~ /index/i)
{
    &index(@ARGV);
} elsif ($op =~ /findbin/i)
{
    &findbin(@ARGV);
} else
{
    die $usage;
}

#-------------------------------------------------------------------------
sub csv2tab
{
#Usage: &csv2tab($infile,$outfile)
#replace all commas with tabs

    my $usage="$PROGRAM csv2tab <infile> <outfile>\n";
    die $usage unless @ARGV==2;
    my $file=shift;
    my $outfile=shift;
    my $out;

    open IN,'<',$file or die "Cannot open $file\n";
    while (<IN>)
    {
	s/,/\t/g;
	$out.=$_;
    }
    close IN;
    open OUT,'>',$outfile or die "Cannot write to $outfile\n";
    print OUT $out;
}

sub rs2avinput
{
    #Usage: &rs2avinput($infile,$outfile,$annodir)
    #convert SNP names (eg rs1234) to standard AVINPUT format (chr,start,end,ref,alt)
    #assume 1st line is header
    my $usage="$PROGRAM rs2avinput <infile> <outfile> <snpcol> <db>\n";
    die $usage unless @ARGV == 4;
    my $in=shift;
    my $out=shift;
    my $snpcol=shift;
    my $db=shift;
    my %snp; #hash of array, key is rsid,value is array of every entry
    my @out;

    my $snpcol_idx=&findSNPColIdx($in,$snpcol);
    open IN,'<',$in or die "Cannot open $in: $!\n";
    open DB,'<',$db or die "Cannot open $db: $!\n";
    while(<IN>)
    {
	chomp;
	push @out,"chr\tstart\tend\tref\talt\t$_\n" and next if $. == 1; #do nothing for header
	#make sure it's tab delimited
	my @fields=split;
	my $rs=$fields[$snpcol_idx];
	push @out,"NA\tNA\tNA\tNA\tNA\t$_\n" and next if $rs !~ /rs\d+/;
	my $pos=`$0 findbin $rs $db`;
	chomp $pos;
	if ($pos ne "")
	{
	    my $exist=0;
	    seek DB,$pos,0;
	    while (my $dbln=<DB>)
	    {
		my @dbf=split(/\t/,$dbln,-1);
		my ($id)= $dbf[5]=~/rs(\d+)/;
		my ($in_id)= $rs=~/rs(\d+)/;
		if ($id > $in_id)
		{
		    push @out,"NA\tNA\tNA\tNA\tNA\t$_\n" unless $exist;
		    last;
		} elsif ($id == $in_id)
		{
		    push @out, join("\t",@dbf[0..4],@fields),"\n";
		    $exist=1;
		}
	    }
	} else
	{
	    push @out,"NA\tNA\tNA\tNA\tNA\t$_\n";
	}
    }
    close IN;
    close DB;

    open OUT,'>',$out or die "Cannot write to $out: $!\n";
    print OUT @out;
    close OUT;
}
sub findSNPColIdx
{
    my $in=shift;
    my $snpcol=shift;

    open IN,'<',$in or die "Cannot open $in\n";
    while (<IN>)
    {
	last if $.>1;
	my @fields=split;
	for my $i(0..$#fields)
	{
	    #make sure it's a whitespace-delimited file
	    if ($fields[$i] eq $snpcol)
	    {
		close IN and return $i;
	    }
	}
    }
    close IN;
    die "Cannot find SNP column.\n";
}

sub index
{
    my $usage="$PROGRAM index <ANNOVAR-dbSNP> <out-prefix>\n";
    die $usage unless @ARGV==2;
    my $db=shift @ARGV;
    my $out_prefix=shift @ARGV;
    my $tmp="/tmp/$$.db.tmp";

    #format:X	1203	1203	A	T/C	rs123
    &extract($db,$tmp);
    &sort($tmp,"$out_prefix.txt");
    &genIdx("$out_prefix.txt","$out_prefix.txt.idx"); #use tell, every 10000 rsIDs
}

sub findbin
{
    my $usage="$PROGRAM findbin <rsID> <processed-dbfile>\n";
    die $usage unless @ARGV==2;
    my ($rs,$db)=@ARGV;
    my $idx="$db.idx";

    die "rsXXXX expected: $rs\n" unless $rs=~/rs(\d+)/;
    my $id=$1;
    my $rs_hash=$id - $id % $BUCKET_NUM;
    &genIdx($db,$idx) unless -f $idx;

    {
	#check lower bound
	my $first=`head -n 1 $idx` or die "$!\n";
	chomp $first;
	my @f=split " ",$first;
	die "2 fields expected: $_ at line $.\n" unless @f==2;
	if ($f[1] > $id)
	{
	    die "$rs smaller than the smallest rsID in $db\n";
	}
	#check upper bound
	my $last=`tail -n 1 $idx` or die "$!\n";
	chomp $last;
	@f=split " ",$last;
	die "2 fields expected: $_ at line $.\n" unless @f==2;
	if ($f[1] < $id)
	{
	    die "$rs larger than the largest rsID in $db\n";
	}
    }
    my $prev_pos=0;
    open IN,'<',$idx or die "Cannot open $idx:$!\n";
    while(<IN>)
    {
	#format:position_in_file\trsID
	chomp;
	my @f=split;
	die "2 fields expected: $_ at line $.\n" unless @f==2;
	if ($f[1] >= $rs_hash) 
	{
	    $f[1]>$rs_hash? print $prev_pos,"\n" : print $f[0],"\n";
	    exit;
        }
	$prev_pos=$f[0];
    }
    close IN;
}

sub genIdx
{
    my $db=shift;
    my $idx=shift;

    open IN,'<',$db or die "Cannot open $db:$!\n";
    open OUT,'>',$idx or die "Cannot write to $idx: $!\n";

    my $last_pos=0;
    my $second_last_pos=0;
    while(<IN>)
    {
	my @f=split(/\t/,$_,-1);
	die "6 fields expected: $_ at line $.\n" if @f!=6;
	my $rs=$f[5];
	die "rsXXXX expected: $rs at line $.\n" unless $rs=~/rs(\d+)/;
	if ($.==1)
	{
	    print OUT "0\t$1\n"; #lower bound
	} else
	{
	    print OUT "$last_pos\t$1\n" if $1 % $BUCKET_NUM == 0;
	}
	$second_last_pos=$last_pos;
	$last_pos=tell;
    }
    {
	seek IN,$second_last_pos,0;
	my $last=<IN>;
	my @f=split(/\t/,$last,-1);
	$f[5]=~/rs(\d+)/;
	print OUT "$second_last_pos\t$1\n" unless $1 % $BUCKET_NUM == 0;
    }
    close IN;
    close OUT;
}

sub sort
{
    my $in=shift;
    my $out=shift;

    my $cmd="perl -pe 's/(\\s)rs(\\d+)\$/\$1\$2/' $in | msort -k n6 | perl -pe 's/(\\s)(\\d+)\$/\$1rs\$2/' > $out";
    !system($cmd) or die "$!";
}

sub extract
{
    my $db=shift;
    my $out=shift;

    warn "Converting ANNOVAR dbSNP file to tab-delimited rsID database.\n".
    "Every line of the output consists of chr, start, end, ref, alt and rsID.\n".
    "One rsID may have multiple hits in the genome.\n";
    open IN,'<',$db or die "Cannot read $db:$!\n";
    open OUT,'>',$out or die "Cannot write to $out: $!\n";
    while (<IN>)
    {
	#below adapted from ANNOVAR
	my @record=split(/\t/,$_,-1); #-1 in case there are empty fields
	@record == 18 or @record == 26 or die "Error: invalid record found in dbSNP database file $db (18 or 26 fields expected but found ${\(scalar @record)}): <$_>\n" . join("\n",@record);
	my ($chr, $start, $end, $rsid, $strand, $ucscallele, $twoallele, $class) = @record[1,2,3,4,6,8,9,11];
	$start++; #UCSC genome coordinates
	$chr=~s/^chr// or die "Error: invalid record found in $db (2nd field should begin with 'chr'): <$_>\n";
	next unless $class=~/single|deletion|in-del|insertion/;
	my @allele = split (/\//, $twoallele);
	@allele >= 2 or next;       

	if ($strand eq '-') 
	{        
	    #handle reverse strand annotation (the vast majority of records in dbSNP should be already in + strand)
	    map { $_=&revcom($_) } @allele ;
	}
	my ($ref,@alt)=@allele; #reports all alternative alleles
	#in-del is usually annotated below, so they require special treatment
	#587     chr1    384538  384539  rs3971283       0       +       T       T       -/ATT   genomic in-del  unknown 0       0       unknown exact   3
	if ($class eq 'in-del') 
	{        #indel are usually annotated as -/xxx, where xxx is the alternative allele
	    @alt = (length ($ucscallele) . $allele[1] );    #prefix a number before the alleles, indicating block substitution
	} elsif ($class eq 'insertion') 
	{
	    $start--;
	    @alt = ("0$allele[1]");
	} elsif ($class eq 'deletion') 
	{
	    @alt = (length ($ucscallele));
	} else 
	{
	    for my $i (0 .. @allele-1) 
	    {
		if ($ucscallele eq $allele[$i]) 
		{
		    @alt = @allele;
		    splice (@alt, $i, 1);
		}
	    }
	    next unless (@alt); #ucscallele is not part of allele description, do not trust this record
	}
	#note that some SNPs (e.g., rs28434453) may hit multiple locations, report all of them
	#585        chr1    13301   13302   rs28434453      0       -       C       C       C/T     genomic single etc...
	#1367    chr15   102517867       102517868       rs28434453      0       +       G       G       C/T     genomic single etc...
	print OUT join("\t",$chr,$start,$end,$ref,join('/',@alt),$rsid),"\n";
    }
    close IN;
    close OUT;
}

sub revcom
{
    my ($seq) = @_;
    $seq = reverse $seq;
    $seq =~ tr/acgtACGT/tgcaTGCA/;
    return ($seq);
}
