#!/usr/bin/env perl

use strict;
use warnings;
use File::Spec;

my $usage=
"Usage: $0 
	rmheader <infile> <outfile>
	csv2tab <infile> <outfile>
	rs2avinput <infile> <outfile> <snpcol> <annodir> <genome_build>\n";
die $usage unless @ARGV>=3;
my $op=shift @ARGV;
my $in=shift @ARGV;
my $out=shift @ARGV;

if ($op =~ /rmheader/i)
{
    &rmHeader($in,$out);
} elsif ($op =~ /csv2tab/i)
{
    &csv2tab($in,$out);
} elsif ($op =~ /rs2avinput/i)
{
    die $usage unless @ARGV == 3;
    &rs2avinput($in,$out,@ARGV);
}else
{
    die "Unrecognized operation\n";
}


#-------------------------------------------------------------------------
sub rmHeader
{
#Usage: &rmHeader($infile,$outfile)
#remove header (1st line)
    my $file=shift;
    my $outfile=shift;
    my $out;

    open IN,'<',$file or die "Cannot open $file\n";
    while (<IN>)
    {
	next if $.==1;
	$out.=$_;
    }
    close IN;
    open OUT,'>',$outfile or die "Cannot write to $outfile\n";
    print OUT $out;
}

sub csv2tab
{
#Usage: &csv2tab($infile,$outfile)
#replace all commas with tabs
    my $file=shift;
    my $outfile=shift;
    my $out;

    open IN,'<',$file or die "Cannot open $file\n";
    while (<IN>)
    {
	s/,/\t/g;
	$out.=$_;
    }
    close IN;
    open OUT,'>',$outfile or die "Cannot write to $outfile\n";
    print OUT $out;
}

sub rs2avinput
{
    #Usage: &rs2avinput($infile,$outfile,$annodir)
    #convert SNP names (eg rs1234) to standard AVINPUT format (chr,start,end,ref,alt)
    #assume 1st line is header
    my $in=shift;
    my $out=shift;
    my $snpcol=shift;
    my $dir=shift;
    my $hg=shift;
    my $db;
    my %snp; #hash of array, key is rsid,value is array of every entry
    my @out;

    #read database
    if ($hg=~/hg18/i)
    {
	$db="hg18_snp135.txt";
    } elsif ($hg=~/hg19/i)
    {
	$db="hg19_snp137.txt";
    } else
    {
	die "Unrecognized genome build: $hg\nhg18 or hg19 expected\n";
    }
    $db=File::Spec->catfile($dir,$db);
    %snp=&readdbSNP($db);
    #do the conversion
    my $snpcol_idx=&findSNPColIdx($in,$snpcol);
    open IN,'<',$in or die "Cannot open $in\n";
    while(<IN>)
    {
	chomp;
	push @out,join("\t","chr","start","end","ref","alt",$_) and next if $. == 1; #skip header
	#make sure it's tab delimited
	my @fields=split;
	my $rs=$fields[$snpcol_idx];
	$rs=lc $rs;
	if ($snp{$rs})
	{
	    for (@{$snp{$rs}})
	    {
		push @out,join("\t",$_,@fields);
	    }
	} else
	{
	    push @out,join("\t",map {"NA"} (1..5),@fields);
	}
    }
    close IN;
    open OUT,'>',$out or die "Cannot write to $out:$!\n";
    print OUT join("\n",@out);
    close OUT;
}

sub readdbSNP
{
    my $db=shift;
    my %snp;

    open IN,'<',$db or die "Cannot read $db\n";
    while (<IN>)
    {
	#below adapted from ANNOVAR
	my @record=split(/\t/,$_,-1); #-1 in case there are empty fields
	#don't check number of fields, cause it is downloaded from ANNOVAR website
	my ($chr, $start, $end, $rsid, $strand, $ucscallele, $twoallele, $class) = @record[1,2,3,4,6,8,9,11];
	$rsid=lc $rsid;
	$chr=lc $chr;
	$class=lc $class;
	$start++; #UCSC genome coordinates
	$chr=~s/^chr//;
	next unless $class=~/single|deletion|in-del|insertion/;


	my @allele = split (/\//, $twoallele);
	@allele >= 2 or next;       

	if ($strand eq '-') 
	{        
	    #handle reverse strand annotation (the vast majority of records in dbSNP should be already in + strand)
	    map { $_=&revcom($_) } @allele ;
	}
	my ($ref,@alt)=@allele; #reports all alternative alleles
	#in-del is usually annotated below, so they require special treatment
	#587     chr1    384538  384539  rs3971283       0       +       T       T       -/ATT   genomic in-del  unknown 0       0       unknown exact   3
	if ($class eq 'in-del') 
	{        #indel are usually annotated as -/xxx, where xxx is the alternative allele
	    @alt = (length ($ucscallele) . $allele[1] );    #prefix a number before the alleles, indicating block substitution
	} elsif ($class eq 'insertion') 
	{
	    $start--;
	    @alt = ("0$allele[1]");
	} elsif ($class eq 'deletion') 
	{
	    @alt = (length ($ucscallele));
	} else 
	{
	    1;
	}
	#note that some SNPs (e.g., rs28434453) may hit multiple locations, report all of them
	#585        chr1    13301   13302   rs28434453      0       -       C       C       C/T     genomic single etc...
	#1367    chr15   102517867       102517868       rs28434453      0       +       G       G       C/T     genomic single etc...
	$snp{$rsid}=[] unless defined $snp{$rsid};
	push @{$snp{$rsid}},join("\t",$chr,$start,$end,$ref,join('/',@alt));
    }
    close IN;
    return %snp;
}

sub findSNPColIdx
{
    my $in=shift;
    my $snpcol=shift;

    open IN,'<',$in or die "Cannot open $in\n";
    while (<IN>)
    {
	last if $.>1;
	my @fields=split;
	for my $i(0..$#fields)
	{
	    #make sure it's a whitespace-delimited file
	    if ($fields[$i] eq $snpcol)
	    {
		return $i;
	    }
	}
    }
    die "Cannot find SNP column.\n";
}

sub revcom 
{
    my ($seq) = @_;
    $seq = reverse $seq;
    $seq =~ tr/acgtACGT/tgcaTGCA/;
    return ($seq);
}

sub index
{

    my ($BIN, $DBSIZE) = (0, 0);
    my %index = ();
    my $bb = {};                    #a subset of %index, which corresponds to the input variants
    my $flag_idx_search = 0;        #indicate if index-based search algorithm is used (faster speed for a small number of input variants)

    if ( -f "$dbfile.idx" ) {
	if (open(IDX, "$dbfile.idx")) {
	    my $line = <IDX>;
	    if (not $line =~ m/BIN\t(\d+)\t(\d+)/) {
		printerr "WARNING: Malformed database index file $dbfile.idx.\n";
	    } elsif ($2 != -s $dbfile) {                    #file version is different, do not use index file in this case
		printerr "WARNING: Your index file $dbfile.idx is out of date and will not be used. ANNOVAR can still generate correct results without index file.\n";
	    } else {
		($BIN, $DBSIZE) = ($1, $2);
		while ( $line = <IDX> ) {
		    $line =~ s/[\r\n]+$//;
		    my ( $chrom, $pos, $offset0, $offset1 ) = split (/\t/, $line);
		    $chrom =~ s/^chr//;             #delete the chr in snp135, etc
		    defined $offset1 or next;       #invalid input line in the index file
		    $index{"$chrom\t$pos"} = [$offset0, $offset1];
		}
	    }
	    close (IDX);
	} else {
	    printerr "WARNING: cannot read from input database index $dbfile.idx: $!\n";
	}
	if (%index) {
	    foreach my $k ( keys %$variant ) {
		my ($chrom, $pos) = split ($;, $k);

		my $bin = $pos - ($pos % $BIN);
		defined $index{"$chrom\t$bin"} or next;

		$bb->{"$chrom\t$bin"}{$k} = $variant->{$k};
	    }

	    if (scalar (keys %$bb) / scalar (keys %index) < $indexfilter_threshold) {
		$flag_idx_search++;
		printerr "NOTICE: Database index loaded. Total number of bins is ".  scalar (keys %index) . " and " . "the number of bins to be scanned is " . scalar (keys %$bb) . "\n";
	    }
	} else {
	    printerr "WARNING: Unable to load database index successfully from file $dbfile.idx.\n";
	}
    }
    if (not $flag_idx_search) {
	$bb = {1, [0, -s "$dbfile"]};
	%index = (1, [0, -s "$dbfile"]);
    }

    open (DB, $dbfile) or die "Error: cannot read from input database file $dbfile: $!\n";
    printerr "NOTICE: Scanning filter database $dbfile...";

    foreach my $b (sort keys %$bb) {
	my ($chunk_min, $chunk_max) = @{ $index{$b} };

	seek(DB, $chunk_min, 0);                                #place file pointer to the chunk_min
	my $chunk_here = $chunk_min;

	while (<DB>) {
	    my $line_length = length($_);                   #calculate line length of the DB

	    my (@obs2, @score2, @start2, @ref2);                            #for 1000G2010 data set in VCF format, some tri-allelic SNPs are present; in the future, some quad-allelic SNPs may be also present in VCF files
	    s/[\r\n]+$//;
	    m/\S/ or next;                                  #skip empty lines in the database file (sometimes this occurs)

	}
    }
}
